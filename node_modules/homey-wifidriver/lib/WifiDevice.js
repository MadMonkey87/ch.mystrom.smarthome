'use strict';

const Homey = require('homey');
const BackOffStrategy = require('./Util/BackOffStrategy');

/**
 * The {@link WifiDevice} class handles common functionalities for WiFi-devices in Homey. It exposes methods for handling
 * polling intervals and backoff strategies (basically an advanced setInterval() for retrying certain things).
 *
 * @extends Homey.Device
 * @example
 *
 * const WifiDevice = require('homey-wifidriver').WifiDevice;
 *
 * class myDevice extends WifiDevice {
 *
 *  onInit() {
 *
 *      // Create initialization back off strategy
 *      if(this.backOffStrategy === 'undefined') {
 *          this.registerBackOffStrategy({
 *              initialDelay: 10000, // 10 seconds
 *              maxDelay: 1000 * 60 * 60, // 1 hour
 *              maxTries: 10, // Optional, max back off tries, if not provided it will not end until reset
 *              onBackOffReady: this.onInit.bind(this), // Optional, if provided this method will be called on each back off
 *              onBackOffFailed: (() => {}), // Optional, this method will be called when back off failed; maxTries was exceeded
 *          })
 *      }
 *
 *      // Method that will create an interval
 *      this.registerPollInterval({
 *          id: 'status',
 *          fn: this.exampleApiClient.getStatus.bind(this.exampleApiClient),
 *          interval: 30000,
 *      });
 *
 *      // To stop polling
 *      this.deregisterPollInterval('status');
 *
 *      if(initializationSuccess === true) {
 *          this.backOffStrategy.abort()
 *      } else {
 *          this.backOffStrategy.backoff()
 *      }
 *  }
 *
 *  onDeleted() {
 *      // Clean up registered polling intervals
 *      super.onDeleted();
 *  }
 * }
 */
class WifiDevice extends Homey.Device {

	onInit() {
		this.log('init WifiDevice');
		this._backOffStrategies = [];
		return Promise.resolve();
	}

	/**
	 * Method that creates and returns a back off strategy (Fibonacci).
	 * @param {Object} options - Specification for initialization backoff strategy
	 * @param {Function} options.onBackOffReady - Function will be called on each back off tick
	 * @param {Function} [options.onBackOffFailed] - Function will be called when back off failed (maxTries exceeded)
	 * @param {number} [options.randomisationFactor=0] - Randomize the interval (0 - 1)
	 * @param {number} [options.initialDelay=10000] - After first failed init wait this long (ms)
	 * @param {number} [options.maxDelay=300000] - Max length of time between init retries (ms)
	 * @param {number} [options.maxTries=infinite] - Max number of initialization retries
	 * @param {boolean} [options.startImmediately=false] - Backoff called on creation
	 * @returns {BackOffStrategy|Error} backOffStrategy - Back off strategy instance
	 */
	registerBackOffStrategy(options = {}) {

		// Create back off strategy
		const backOffStrategy = new BackOffStrategy(options);

		// Remove from list on abort
		backOffStrategy.on('abort', id => this._backOffStrategies.splice(this._backOffStrategies.findIndex(i => i.id === id), 1));

		// Can not add duplicate ids
		if (this._backOffStrategies.findIndex(i => i.id === backOffStrategy.id) !== -1) {
			return new Error('back_off_strategy_id_duplicate');
		}
		this._backOffStrategies.push(backOffStrategy);
		return backOffStrategy;
	}

	/**
	 * Method that adds a poll interval to the list, and starts polling on the provided interval.
	 * @param {Object} options
	 * @param {string} options.id - Custom id of poll interval
	 * @param {function} options.fn - Method that will be called when polling
	 * @param {number} options.interval - Time in ms between polling intervals
	 */
	registerPollInterval(options = {}) {
		if (typeof this.pollIntervals === 'undefined') this.pollIntervals = {};
		if (this.pollIntervals.hasOwnProperty(options.id)) this.deregisterPollInterval(options.id);
		this.pollIntervals[options.id] = setInterval(options.fn, options.interval);
		this.log(`registered polling interval (id: ${options.id}, interval: ${options.interval}ms)`);
	}

	/**
	 * Method that clears the poll interval and removes the registered interval from the list.
	 * @param {string} id - poll interval identifier
	 */
	deregisterPollInterval(id) {
		if (typeof this.pollIntervals === 'undefined') return;
		clearInterval(this.pollIntervals[id]);
		delete this.pollIntervals[id];
		this.log(`de-registered polling interval (id: ${id})`);
	}

	/**
	 * This method will be called when the device has been deleted, it makes
	 * sure the client is properly destroyed and left over settings are removed.
	 */
	onDeleted() {
		this.log('onDeleted() -> WifiDevice');
		// Deregister all poll intervals
		Object.keys(this.pollIntervals || {}).forEach(id => this.deregisterPollInterval(id));

		// Abort all registered backOffStrategy
		this._backOffStrategies.forEach(strategy => strategy.abort());
	}
}

module.exports = WifiDevice;
