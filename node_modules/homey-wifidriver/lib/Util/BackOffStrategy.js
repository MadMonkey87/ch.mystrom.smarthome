'use strict'

const Homey = require('homey');
const Backoff = require('backoff');
const EventEmitter = require('events');
const uuid = require('uuid/v4');

class BackOffStrategy extends EventEmitter {
	constructor(options = {}) {
		super();

		this.log = Homey.app.log.bind(this);

		// Create back off strategy
		this._backOffStrategy = Backoff.fibonacci({
			randomisationFactor: options.randomisationFactor || 0,
			initialDelay: options.initialDelay || 10000,
			maxDelay: options.maxDelay || 300000,
		});

		this.id = options.id || uuid();
		this.isReset = false;

		// If provided, set max number of tries
		if (typeof options.maxTries === 'number') {
			this._backOffStrategy.failAfter(options.maxTries);
		}

		// After back off has been executed, call onBackOffReady() (if provided) or onInit()
		this._backOffStrategy.on('ready', async (number, delay) => {

			// Compensate for possible startImmediately
			number++;

			this.log(`backOffStrategy tick ${number}, delay is ${delay} (id: ${this.id})`);

			// Call onBackOffReady
			if (typeof options.onBackOffReady === 'function' && !this.isReset) {
				this.pendingBackOffReady = options.onBackOffReady.call(this, this._backOffStrategy);

				// If it returns a promise, handle backoff/resetting automatically
				if (this.pendingBackOffReady instanceof Promise) {
					this.pendingBackOffReady
						.then(() => this.abort())
						.catch(() => this.backoff())
				}
			}
		});

		// If custom onBackOffFailed() method is provided, bind it to the fail event
		if (options.onBackOffFailed) {
			this.onBackOffFailed = options.onBackOffFailed;
			this._backOffStrategy.on('fail', () => this.onBackOffFailed.call(this, this._backOffStrategy));
		}

		// Bind abort handler
		this._backOffStrategy.on('fail', () => {
			this.log(`backOffStrategy failed (id: ${this.id})`);
			this.abort();
		});

		// If desired start with an immediate backoff
		if (options.startImmediately) this._backOffStrategy.emit('ready', -1, 0);

		// Store index for later removal
		this.log(`backOffStrategy created (id: ${this.id})`);
	}

	abort() {
		this.log(`backOffStrategy aborted (id: ${this.id})`);
		this.isReset = true;
		this._backOffStrategy.reset();
		this._backOffStrategy.removeAllListeners();
		if (typeof this.onBackOffFailed === 'function') this.onBackOffFailed.call(this, this._backOffStrategy);
		process.nextTick(() => this.emit('abort', this.id));
	}

	backoff() {
		if (!this.isReset) this._backOffStrategy.backoff();
	}
}

module.exports = BackOffStrategy;