'use strict';

const _ = require('underscore');
const limit = require('simple-rate-limiter');

let debug = false;

/**
 * The {@link PromiseQueue} class, keeps track of a queue containing native Promises. It will process each Promise
 * sequentially, or parallel depending on the concurrency.
 */
class PromiseQueue {

	/**
	 * PromiseQueue constructor
	 * @param {Object} options
	 * @param {number} [options.concurrency=1] - Number of parallel requests allowed
	 * @param {number} [options.throttle=0] - Wait in ms between requests
	 * @param {Object} [options.rateLimit]
	 * @param {number} [options.rateLimit.max] - Maximum number of queue items per time unit
	 * @param {number} [options.rateLimit.per] - Time in ms
	 */
	constructor(options) {
		options = options || {};
		this._concurrency = options.concurrency || 1;
		this._queue = [];

		// Rate limit api calls
		if (typeof options.rateLimit === 'object' &&
			typeof options.rateLimit.max === 'number' &&
			typeof options.rateLimit.per === 'number') {
			if (debug) console.log('set rate limit to', options.rateLimit.max, 'per', options.rateLimit.per, 'ms');
			this._rateLimitQueue(options.rateLimit.max, options.rateLimit.per);
		}

		// Throttle api calls
		if (typeof options.throttle === 'number') {
			if (debug) console.log('throttle queue for', options.throttle, 'ms');
			this._throttleQueue(options.throttle);
		}
	}

	/**
	 * PromiseQueue size getter.
	 * @returns {number} - Current queue length (number of promises in queue)
	 */
	get size() {
		return this._queue.length;
	}

	/**
	 * Add a Promise to the queue, if the queue is empty it will be executed
	 * immediately, else it will wait for the other Promises to resolve/reject.
	 * @param fn {Function} Wrapper function which should return a Promise
	 * @param {Object} options
	 * @param {boolean} options.priority - If true promise will be added as first item
	 * @returns {Promise}
	 */
	add(fn, options = {}) {
		if (debug) console.log(`add() -> queue size: ${this.size}`);

		return new Promise((resolve, reject) => {

			// Wrapper function which will execute the provided Promise
			const execute = (override) => {

				// If queue needs to be aborted
				if (override) return reject(override);

				fn()
					.then(result => {
						// Promise has been completed, remove from queue
						this.remove(execute, false);

						// Wait for next tick to execute next Promise
						process.nextTick(this._next.bind(this));
						return resolve(result);
					})
					.catch(err => {
						// Promise has been completed, remove from queue
						this.remove(execute, false);

						// Wait for next tick to execute next Promise
						process.nextTick(this._next.bind(this));
						return reject(err);
					});
			};

			// Push execute function to queue, if priority call add it to the front
			if (options.priority) this._queue.unshift(execute);
			else this._queue.push(execute);

			// If queue length is less then the allowed concurrency execute
			if (this.size <= this._concurrency) this._next();
		});
	}

	/**
	 * Remove a Promise from the PromiseQueue
	 * @param {function} fn - Wrapper function which should return a Promise
	 * @param {boolean} [reject] - If undefined the Promise to be removed will be rejected
	 */
	remove(fn, reject) {
		if (debug) console.log(`remove() -> before -> queue size: ${this.size}`);

		// Reject the Promise
		if (typeof reject === 'undefined') fn('removed');

		// Remove Promise from the queue
		this._queue = this._queue.filter(promise => promise !== fn);
		if (debug) console.log(`remove() -> after -> queue size: ${this.size}`);

	}

	/**
	 * Abort all non-executed Promises in the queue.
	 */
	abort() {
		if (debug) console.log(`abort() -> before -> queue size: ${this.size}`);
		this._queue.forEach(fn => {
			fn('aborted');
			this.remove(fn);
		});
		if (debug) console.log(`abort() -> after -> queue size: ${this.size}`);
	}

	/**
	 * Method that will rate limit the _next method, this will ensure that queue items do not get
	 * executed more than a defined number of times per time unit.
	 * @param {number} max - Max requests per time unit
	 * @param {number} per - Time in ms
	 * @private
	 */
	_rateLimitQueue(max, per) {
		this._next = limit(this._next.bind(this)).to(max).per(per);
	}

	/**
	 * Method that will throttle the _next method, this will ensure that queue items will always
	 * have a certain time between them.
	 * @param {number} wait - Time in ms between queue items
	 * @private
	 */
	_throttleQueue(wait) {
		this._next = _.throttle(this._next.bind(this), wait, { leading: false });
	}

	/**
	 * Fetch the next Promise in the queue and execute it.
	 * @private
	 */
	_next() {
		if (debug) console.log(`next() -> queue size: ${this.size}`);
		const execute = this._queue.shift();
		if (typeof execute !== 'undefined') {
			execute.call(this);
		}
	}
}

module.exports = PromiseQueue;
